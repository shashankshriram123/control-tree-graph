<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Tree Graph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #1a1a1a;
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: grab;
        }
        canvas.panning {
            cursor: grabbing;
        }
        .control-panel {
            background-color: rgba(40, 40, 40, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .btn {
            transition: all 0.2s ease-in-out;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #log-container {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.875rem;
        }
        #log-container p {
            padding: 0.25rem 0.5rem;
            border-bottom: 1px solid #4a5568;
        }
        #log-container p:last-child {
            border-bottom: none;
        }
        /* Context Menu Styles */
        #context-menu {
            position: absolute;
            display: none;
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            width: 180px;
        }
        #context-menu button {
            display: block;
            width: 100%;
            padding: 0.75rem 1rem;
            text-align: left;
            color: #e2e8f0;
            background: none;
            border: none;
            border-bottom: 1px solid #4a5568;
            cursor: pointer;
        }
        #context-menu button:hover {
            background-color: #4a5568;
        }
        #context-menu button:disabled {
            color: #718096;
            cursor: not-allowed;
            background-color: transparent;
        }
        #context-menu button:last-child {
            border-bottom: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center h-screen p-4">

    <div class="w-full max-w-4xl mx-auto flex flex-col items-center gap-4">
        <h1 class="text-2xl font-bold text-gray-200">Control Tree Graph</h1>
        <canvas id="treeCanvas" width="800" height="500"></canvas>
        <div class="control-panel p-4 rounded-lg shadow-lg w-full max-w-md flex items-center justify-center gap-4">
            <button id="createSubBranchBtn" class="btn bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg shadow-md" disabled>Create Sub-Branch</button>
            <button id="expandBranchBtn" class="btn bg-teal-600 hover:bg-teal-500 text-white font-bold py-2 px-4 rounded-lg shadow-md" disabled>Expand Head Node</button>
        </div>
        <div id="infoPanel" class="text-gray-400 text-sm h-6 text-center">
            Click a node to select it. Long-press for more options.
        </div>
        <div class="w-full max-w-4xl mt-4">
            <h2 class="text-lg font-semibold text-gray-300 mb-2">Action Log</h2>
            <div id="log-container" class="w-full rounded-lg p-2"></div>
        </div>
    </div>

    <!-- Context Menu HTML -->
    <div id="context-menu">
        <button id="delete-branch-btn">Delete Branch</button>
    </div>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');

        // --- DOM Elements ---
        const createSubBranchBtn = document.getElementById('createSubBranchBtn');
        const expandBranchBtn = document.getElementById('expandBranchBtn');
        const infoPanel = document.getElementById('infoPanel');
        const logContainer = document.getElementById('log-container');
        const contextMenu = document.getElementById('context-menu');
        const deleteBranchBtn = document.getElementById('delete-branch-btn');

        // --- Configuration ---
        const NODE_RADIUS = 10;
        const NODE_SELECTED_RADIUS = 12;
        const BRANCH_WIDTH = 5;
        const BRANCH_COLORS = ['#f59e0b', '#10b981', '#3b82f6', '#ec4899', '#8b5cf6', '#ef4444'];
        const GRID_SPACING = 80;
        const LONG_PRESS_DURATION = 500; // ms

        // --- Data & State ---
        let branches = [];
        let selectedNode = null;
        let nextColorIndex = 0;
        let nextNodeId = 1;
        let nextBranchId = 1;
        let actionLog = [];
        let camera = { x: -canvas.width / 3, y: -canvas.height / 2 + 50 };
        
        // Interaction State
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let longPressTimer = null;
        let contextMenuNode = null;
        let mouseDownNode = null;
        let mouseDownPos = null;

        // Represents a single node in the graph
        class Node {
            constructor(x, y, branch) {
                this.id = nextNodeId++;
                this.x = x;
                this.y = y;
                this.branch = branch;
                this.isHead = false;
            }
            draw() {
                ctx.beginPath();
                const radius = (this === selectedNode || this === contextMenuNode) ? NODE_SELECTED_RADIUS : NODE_RADIUS;
                const color = (this === selectedNode) ? '#ffffff' : this.branch.color;
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
                if (this !== selectedNode) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, NODE_RADIUS * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fill();
                }
            }
            isClicked(pointX, pointY) {
                const distance = Math.sqrt(Math.pow(this.x - pointX, 2) + Math.pow(this.y - pointY, 2));
                return distance < NODE_RADIUS * 1.5;
            }
        }

        // Represents a branch, which is a collection of nodes
        class Branch {
            constructor(color, parentNode = null) {
                this.id = nextBranchId++;
                this.nodes = [];
                this.color = color;
                this.parentNode = parentNode;
            }
            addNode(node) {
                this.nodes.push(node);
                this.nodes.sort((a, b) => b.y - a.y);
            }
            draw() {
                if (this.nodes.length < 1) return;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = BRANCH_WIDTH;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                if (this.parentNode) {
                    ctx.beginPath();
                    ctx.moveTo(this.parentNode.x, this.parentNode.y);
                    ctx.lineTo(this.nodes[0].x, this.nodes[0].y);
                    ctx.stroke();
                }
                for (let i = 0; i < this.nodes.length - 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.nodes[i].x, this.nodes[i].y);
                    ctx.lineTo(this.nodes[i+1].x, this.nodes[i+1].y);
                    ctx.stroke();
                }
            }
        }

        // --- Core Logic Functions ---
        function init() {
            branches = [];
            actionLog = [];
            nextNodeId = 1;
            nextBranchId = 1;
            nextColorIndex = 0;
            const mainBranch = new Branch(getNextColor());
            const startX = Math.round(canvas.width / 2);
            const rootNode = new Node(startX, Math.round(canvas.height / 2 + GRID_SPACING), mainBranch);
            const middleNode = new Node(startX, Math.round(canvas.height / 2), mainBranch);
            const headNode = new Node(startX, Math.round(canvas.height / 2 - GRID_SPACING), mainBranch);
            headNode.isHead = true;
            mainBranch.addNode(rootNode);
            mainBranch.addNode(middleNode);
            mainBranch.addNode(headNode);
            branches.push(mainBranch);
            logAction(`INIT: Created Main Branch #${mainBranch.id} with Nodes #${rootNode.id}, #${middleNode.id}, #${headNode.id}.`);
            draw();
        }

        function relayout() {
            logAction(`RELAYOUT: Reorganizing entire graph.`);
            console.log("--- STARTING RECURSIVE RELAYOUT V7 ---");

            const mainBranch = branches.find(b => b.parentNode === null);
            if (!mainBranch) return;

            const childrenMap = new Map();
            branches.forEach(b => {
                if (b.parentNode) {
                    const parentId = b.parentNode.branch.id;
                    if (!childrenMap.has(parentId)) childrenMap.set(parentId, []);
                    childrenMap.get(parentId).push(b);
                }
            });

            for (const children of childrenMap.values()) {
                children.sort((a, b) => a.parentNode.y - b.parentNode.y);
            }

            const newPositions = new Map();

            function layoutSubtree(branch, startX) {
                console.log(`Layouting subtree for Branch #${branch.id} starting at X=${startX}`);
                newPositions.set(branch.id, startX);
                
                let currentX = startX;
                const children = childrenMap.get(branch.id) || [];
                
                if (children.length > 0) {
                    children.forEach(child => {
                        const childStartX = currentX + GRID_SPACING;
                        const subtreeEndX = layoutSubtree(child, childStartX);
                        currentX = subtreeEndX;
                    });
                    return currentX;
                } else {
                    return startX;
                }
            }

            let currentX = mainBranch.nodes[0].x;
            const rootChildren = childrenMap.get(mainBranch.id) || [];
            rootChildren.forEach(child => {
                const childStartX = currentX + GRID_SPACING;
                const subtreeEndX = layoutSubtree(child, childStartX);
                currentX = subtreeEndX;
            });

            console.log("PASS 2: Applying new positions...");
            branches.forEach(branch => {
                if (newPositions.has(branch.id)) {
                    const targetX = newPositions.get(branch.id);
                    const currentX = branch.nodes[0].x;
                    const shiftX = targetX - currentX;

                    if (shiftX !== 0) {
                        logAction(`  -> SHIFT: Branch #${branch.id} moved to X=${targetX}.`);
                        branch.nodes.forEach(node => node.x += shiftX);
                    }
                }
            });
            console.log("--- RECURSIVE RELAYOUT COMPLETE ---");
        }


        function createSubBranch() {
            if (!selectedNode) return;
            const parentNode = selectedNode;
            if (branches.some(b => b.parentNode === parentNode)) {
                infoPanel.textContent = "This node already has a sub-branch.";
                return;
            }
            const newBranch = new Branch(getNextColor(), parentNode);
            const newNode = new Node(parentNode.x + GRID_SPACING, parentNode.y, newBranch);
            newNode.isHead = true;
            newBranch.addNode(newNode);
            branches.push(newBranch);
            logAction(`CREATE: Branch #${newBranch.id} (Node #${newNode.id}) from Parent Node #${parentNode.id}.`);
            relayout();
            deselectNode();
            draw();
        }

        function expandBranch() {
            if (!selectedNode || !selectedNode.isHead) return;
            const headNode = selectedNode;
            const branch = headNode.branch;
            headNode.isHead = false;
            const newHeadNode = new Node(headNode.x, headNode.y - GRID_SPACING, branch);
            newHeadNode.isHead = true;
            branch.addNode(newHeadNode);
            logAction(`EXPAND: Branch #${branch.id} with new Head Node #${newHeadNode.id}.`);
            relayout();
            selectNode(newHeadNode);
            draw();
        }

        // --- Context Menu Logic ---
        function showContextMenu(x, y, node) {
            contextMenuNode = node;
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.style.display = 'block';
            deleteBranchBtn.disabled = node.branch.parentNode === null;
            draw();
        }

        function hideContextMenu() {
            if (contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
                contextMenuNode = null;
                draw();
            }
        }

        deleteBranchBtn.addEventListener('click', () => {
            if (!contextMenuNode) return;
            const branchToDelete = contextMenuNode.branch;
            logAction(`DELETE: Branch #${branchToDelete.id} and all its children.`);
            const branchesToRemove = new Set([branchToDelete]);
            let search = true;
            while(search) {
                search = false;
                branches.forEach(b => {
                    if (b.parentNode && branchesToRemove.has(b.parentNode.branch)) {
                        if (!branchesToRemove.has(b)) {
                            branchesToRemove.add(b);
                            search = true;
                        }
                    }
                });
            }
            branches = branches.filter(b => !branchesToRemove.has(b));
            hideContextMenu();
            relayout();
        });

        // --- Logging and UI Update ---
        function logAction(message) {
            const timestamp = new Date().toLocaleTimeString();
            actionLog.push(`[${timestamp}] ${message}`);
            console.log(`[LOG] ${message}`);
            renderLog();
        }
        function renderLog() {
            logContainer.innerHTML = actionLog.map(msg => `<p>${msg}</p>`).join('');
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        function getNextColor() {
            const color = BRANCH_COLORS[nextColorIndex];
            nextColorIndex = (nextColorIndex + 1) % BRANCH_COLORS.length;
            return color;
        }
        function selectNode(node) {
            selectedNode = node;
            updateUI();
        }
        function deselectNode() {
            selectedNode = null;
            updateUI();
        }
        function updateUI() {
            if (selectedNode) {
                const hasSubBranch = branches.some(b => b.parentNode === selectedNode);
                createSubBranchBtn.disabled = hasSubBranch;
                expandBranchBtn.disabled = !selectedNode.isHead;
                let infoText = `Node #${selectedNode.id} on Branch #${selectedNode.branch.id} selected.`;
                if(selectedNode.isHead) infoText += ' This is a head node.';
                if(hasSubBranch) infoText += ' It already has a sub-branch.';
                infoPanel.innerHTML = infoText;
            } else {
                createSubBranchBtn.disabled = true;
                expandBranchBtn.disabled = true;
                infoPanel.textContent = 'Click a node to select it. Long-press for more options.';
            }
        }
        
        // --- Drawing & Rendering ---
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            const startX = Math.floor(-camera.x / GRID_SPACING) * GRID_SPACING;
            const startY = Math.floor(-camera.y / GRID_SPACING) * GRID_SPACING;
            for (let x = startX; x < canvas.width - camera.x; x += GRID_SPACING) {
                ctx.beginPath();
                ctx.moveTo(x, -camera.y);
                ctx.lineTo(x, canvas.height - camera.y);
                ctx.stroke();
            }
            for (let y = startY; y < canvas.height - camera.y; y += GRID_SPACING) {
                ctx.beginPath();
                ctx.moveTo(-camera.x, y);
                ctx.lineTo(canvas.width - camera.x, y);
                ctx.stroke();
            }
        }
        function draw() {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(camera.x, camera.y);
            drawGrid();
            branches.forEach(branch => branch.draw());
            branches.forEach(branch => branch.nodes.forEach(node => node.draw()));
            ctx.restore();
        }

        // --- Event Listeners ---
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left - camera.x,
                y: e.clientY - rect.top - camera.y
            };
        }
        function getScreenPos(e) {
            return { x: e.clientX, y: e.clientY };
        }

        function cancelLongPress() {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        }

        canvas.addEventListener('mousedown', (e) => {
            hideContextMenu();
            cancelLongPress();
            
            mouseDownPos = { x: e.clientX, y: e.clientY };
            const worldPos = getMousePos(e);
            
            mouseDownNode = null;
            for (const branch of branches) {
                for (const node of branch.nodes) {
                    if (node.isClicked(worldPos.x, worldPos.y)) {
                        mouseDownNode = node;
                        break;
                    }
                }
                if (mouseDownNode) break;
            }

            if (mouseDownNode) {
                longPressTimer = setTimeout(() => {
                    const screenPos = getScreenPos(e);
                    showContextMenu(screenPos.x, screenPos.y, mouseDownNode);
                    longPressTimer = null;
                    mouseDownNode = null;
                }, LONG_PRESS_DURATION);
            } else {
                isPanning = true;
                canvas.classList.add('panning');
                panStart.x = e.clientX - camera.x;
                panStart.y = e.clientY - camera.y;
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!mouseDownPos) return;

            const dx = Math.abs(e.clientX - mouseDownPos.x);
            const dy = Math.abs(e.clientY - mouseDownPos.y);
            const moveThreshold = 5;

            if (dx > moveThreshold || dy > moveThreshold) {
                cancelLongPress();
                if (!isPanning && !mouseDownNode) {
                    isPanning = true;
                    canvas.classList.add('panning');
                    panStart.x = e.clientX - camera.x;
                    panStart.y = e.clientY - camera.y;
                }
            }
            
            if (isPanning) {
                camera.x = e.clientX - panStart.x;
                camera.y = e.clientY - panStart.y;
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (longPressTimer) {
                cancelLongPress();
                if (mouseDownNode) {
                    selectNode(mouseDownNode);
                    draw();
                }
            } else if (!isPanning && !contextMenuNode) {
                 deselectNode();
                 draw();
            }

            isPanning = false;
            canvas.classList.remove('panning');
            mouseDownNode = null;
            mouseDownPos = null;
        });

        canvas.addEventListener('mouseleave', () => {
            cancelLongPress();
            isPanning = false;
            canvas.classList.remove('panning');
            mouseDownNode = null;
            mouseDownPos = null;
        });
        
        // Global click listener to hide context menu
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                hideContextMenu();
            }
        });

        createSubBranchBtn.addEventListener('click', createSubBranch);
        expandBranchBtn.addEventListener('click', expandBranch);
        
        window.addEventListener('resize', () => {
            draw();
        });
        
        // --- Start the application ---
        init();
    </script>
</body>
</html>
